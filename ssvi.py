# The first part of the code is where the data is imported and the libraries imported

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.stats import norm
import scipy as sp
import warnings
from timeit import default_timer as timer
import seaborn as sns
from scipy.interpolate import interp1d
from collections import Counter
from scipy.optimize import NonlinearConstraint

# Then the data is sorted and variables that will be used created

print(len(df['Vol'] > 0))
df = df[(df['Bidc'] > 0.05) & (df['Askc'] > 0.05)]
df = df[(df['Vol'] > 0)]
print(len(df['Vol']))

print(Counter(df['Expiry']))
df = df[['Strike','Expiry','Bidc','Askc','IV','Vol',]] 
df['Mid_price'] = (df['Askc'] + df['Bidc']) / 2
df = df.round({'Expiry': 4})
df['forward'] = np.exp(df['Expiry'] * r) * S0
df['k']  = np.log(df['Strike'] / df['forward'])
df['spread'] = ((df['Askc'] - df['Bidc']) / df['forward'])

# Following this the non-liquid observations are filtered out. This entails creating a relative ratio of the volume and setting an appropriate cut-off point.

temporary_vol = []
for i in df.Expiry.unique():
    temporary_df = df.loc[df['Expiry'] == i]
    maxvol = temporary_df['Vol'].max()
    temporary_df = temporary_df.reset_index()
    for j in range(len(temporary_df.Expiry)):
        result = temporary_df.Vol[j] / maxvol
        temporary_vol.append(result) 
df['Relative Volume'] = temporary_vol

df = df[(df['Relative Volume'] > 0.005)]
plt.hist(df['Relative Volume'],bins = 100)
len(df['Expiry'])

# The Newton-Raphson algorithm is used to find the implied volatility of each contract. Then this is inspected to see if they converge on the value observed in the market.

start = timer()
warnings.simplefilter("ignore")
def call_option(S0,K,T,r,sigma):
    d1 = (np.log(S0 / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = (np.log(S0 / K) + (r - 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    call_price = (S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2))
    return call_price

def Call_newton(sigma, S0, K, T, r, C) : return call_option(S0, K, T, r, sigma) - C
df['Impvol'] = [sp.optimize.newton(Call_newton, IV+1, args=(S0,K,T,r,C), tol = 1e-8, rtol = 1e-8, disp = False, maxiter = 2000) for C,K,T,IV in zip(df['Mid_price'], df['Strike'], df['Expiry'], df['IV'])]
df['Impvol_bid'] = [sp.optimize.newton(Call_newton, IV+1, args=(S0,K,T,r,C), tol = 1e-5, rtol = 1e-5, disp = False, maxiter = 1000) for C,K,T,IV in zip(df['Bidc'], df['Strike'], df['Expiry'], df['IV'])]
df['Impvol_ask'] = [sp.optimize.newton(Call_newton, IV+1, args=(S0,K,T,r,C), tol = 1e-5, rtol = 1e-5, disp = False, maxiter = 1000) for C,K,T,IV in zip(df['Askc'], df['Strike'], df['Expiry'], df['IV'])]
end = timer()
print("time elapsed:", (end - start),"seconds")

# In this part the implied volatilities generated by the Newton-Raphson algorithm are evaluated, to see that they converge on the value seen in the market.
df['d1'] = (np.log(S0 / df['Strike']) + (r + 0.5 * df['Impvol'] ** 2) * df['Expiry']) / (df['Impvol'] * np.sqrt(df['Expiry']))
df['d2'] = (np.log(S0 / df['Strike']) + (r - 0.5 * df['Impvol'] ** 2) * df['Expiry']) / (df['Impvol'] * np.sqrt(df['Expiry']))
df['Call_option_check'] = S0 * norm.cdf(df['d1']) - df['Strike'] * np.exp(-r * df['Expiry']) * norm.cdf(df['d2'])
df['diff'] = df['Call_option_check'] - df['Mid_price']
df['w'] = df['Impvol'] * df['Expiry']
df['w_bid'] = df['Impvol_bid'] * df['Expiry']
df['w_ask'] = df['Impvol_ask'] * df['Expiry']
print("Values that did not converge:",np.sum((df['diff'] >  0.01) | (df['diff'] < -0.01)))
print("Min of non-convergence:",np.min(df['diff']))
print("Max of non-convergence:",np.max(df['diff']))
df = df[(df['diff'] < 0.05) & (df['diff'] > -0.05)]
print("Non-converged values after filtering out large errors",np.sum((df['diff'] >  0.01) | (df['diff'] < -0.01)))
print("Min of new non-convergence:",np.min(df['diff']))
print("Max of new non-convergence:",np.max(df['diff']))
Counter(df['Expiry'])

# The section where weights of each option contract is used to prepare the weights for the optimization algorithm. This includes vega, bid-ask spread and volume.

df['weight'] = 1 / ((df['Askc'] - df['Bidc'])) 
df = df[(df['w'] > -1) & (df['w'] < 1)]
df = df[(df['w_bid'] > -1) & (df['w_bid'] < 1)]
df = df[(df['w'] > -1) & (df['w'] < 1)]
Counter(df['Expiry'])

# The theta of each maturity is then found using interpolation techniques through the interp1d package.

theta_col = []
for i in df.Expiry.unique():
    theta = 0
    df_temporary = df.loc[df['Expiry'] == i]
    k_vec = np.log(df_temporary.Strike / df_temporary['forward'])
    inter = interp1d(k_vec, df_temporary['w'], kind = 'cubic', fill_value= "extrapolate")
    iv_ATM = inter(0)
    theta = float(iv_ATM)
    for j in range(len(df_temporary.Expiry)):
        theta_col.append(theta)
df['theta'] = theta_col

# Then we have the differential evolution algorithm that sets the optimal parameters and then calculates the values of the model.

start = timer()
def power_parametrization(eta, gamma, theta):
    return eta * (theta ** (-gamma))

def total_variance(theta, k, rho, phi):
    return (theta / 2) * (1 + rho * phi * k + np.sqrt((phi * k + rho) ** 2 + (1 - rho ** 2)))

def objective_function(x):
    temporary_error = []
    for k, w, theta, weight in zip(df['k'], df['w'], df['theta'], df['weight']):
        phi = power_parametrization(x[1], x[2], theta)
        model_value = total_variance(theta, k, x[0], phi)
        temporary_error.append(((model_value - w) * weight) ** 2)
    RMSE = np.sqrt(sum(temporary_error) / len(temporary_error)) 
    return RMSE
    
def constraint(x):
    for theta in zip(df['theta']):
        phi = power_parametrization(x[1], x[2], theta)
    return theta * (phi ** 2) * (1 + abs(x[0]))
    
def calibration_function():
    nlc = NonlinearConstraint(constraint, -np.inf, 4)
    x = [-0.4, 0.9, 0.3]
    bnds = [(-1,1),(0,4),(0,1)]
    res = sp.optimize.differential_evolution(objective_function, bounds = bnds, atol = 1e-8, tol = 1e-10, maxiter = 800, constraints = (nlc))
    x = np.array(res.x)
    print(x) # This command gives you the calibrated values
    return x    

def modelvalues_function():
    x = calibration_function()
    values = []
    for k, theta in zip(df['k'], df['theta']):
        phi = power_parametrization(x[1], x[2], theta)
        modelval = total_variance(theta, k, x[0], phi)
        values.append(modelval)
    return np.array(values)

model_values = modelvalues_function()
df['Total Implied Variance'] = model_values.tolist()
end = timer()
print("The optimization algorithm takes",(end - start),"seconds") 

# These are then plotted using the Seaborn package as the log-srike against total implied variance. The graphical output also includes error plots to observe the accuracy of the model.

%matplotlib notebook
df['Log-Strike'] = df['k'] * 1
print("The amount of contracts being plotted is:", len(df.k))
ssvi_plot = sns.FacetGrid(df, col = 'Expiry', col_wrap = 4, sharey = False, sharex = False, legend_out = True)
ssvi_plot.map(sns.scatterplot, 'Log-Strike', 'w_bid', s = 15)
ssvi_plot.map(sns.scatterplot, 'Log-Strike', 'w_ask', color = 'r', s = 15)
ssvi_plot.map(sns.lineplot, 'Log-Strike', 'Total Implied Variance', linewidth = 0.4, color = 'k')
plt.savefig('ssvi.png')
plt.show()

# The error plots need to be generated
df['model_price'] = [call_option(S0,K,T,r,sigma) for K,T,sigma in zip(df['Strike'], df['Expiry'], df['test'])]
df['Price diff in bps of frwd'] = abs((((df['Askc'] - df['Bidc'])/2) / df['forward']) * 10000)
df['error'] = abs(((df['Mid_price'] - df['model_price']) / df['forward']) * 10000) # In bps
error_plot = sns.FacetGrid(df, col = 'Expiry', col_wrap = 4, sharey = False, sharex = False, legend_out = True)
error_plot = error_plot.map(sns.scatterplot, 'Log-Strike', 'error', s = 30, marker = "+")
error_plot.map(sns.lineplot, 'Log-Strike', 'error',linewidth = 0.1)
error_plot.map(sns.scatterplot, 'Log-Strike', 'Price diff in bps of frwd', s = 15, color = 'r')
error_plot.map(sns.lineplot, 'Log-Strike', 'Price diff in bps of frwd', linewidth = 0.1, color = 'r')
plt.savefig('error.png')
plt.show()

#The final step calculates the errors for each maturity, in addition to the average spread over all options.
df.groupby('Expiry')['error'].mean()
((df['spread'] / df['forward']) * 10000).mean()
